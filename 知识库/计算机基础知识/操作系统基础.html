<!DOCTYPE html>
<html lang="zh-CH">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>引论 | Justin3go's Blog-🖊</title>
    <meta name="description" content="我的技术博客，用心记录知识碎片，汇总整理程序员知识。">
    <link rel="stylesheet" href="/assets/style.8a11ac97.css">
    <link rel="modulepreload" href="/assets/Home.fc8ba9e3.js">
    <link rel="modulepreload" href="/assets/app.0b1f5e83.js">
    <link rel="modulepreload" href="/assets/知识库_计算机基础知识_操作系统基础.md.268c0b83.lean.js">
    
    <link rel="icon" href="/ava.ico">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-alpha/dist/katex.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css">
  <meta name="twitter:title" content="引论 | Justin3go&#39;s Blog-🖊">
  <meta property="og:title" content="引论 | Justin3go&#39;s Blog-🖊">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="Justin3go&#39;s Blog-🖊, back to home" data-v-675d8756 data-v-cc01ef16><!----> Justin3go&#39;s Blog-🖊</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/" data-v-b8818f8c>首页 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item active" href="/知识库/" data-v-b8818f8c>知识库 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/推荐/" data-v-b8818f8c>站长推荐 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://space.bilibili.com/434542518" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>B站 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://github.com/Justin3go" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/" data-v-b8818f8c>首页 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item active" href="/知识库/" data-v-b8818f8c>知识库 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/推荐/" data-v-b8818f8c>站长推荐 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://space.bilibili.com/434542518" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>B站 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://github.com/Justin3go" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/">算法与数据结构</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/01基础概念">基础概念</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/02线性表">线性表</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/03栈和队列">栈和队列</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/04数组">数组</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/05树">树</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/06图">图</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/07查找">查找</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/08排序">排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/09散列表实现查找">散列表实现查找</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/10算法概述">算法概述</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/11递归与分治">递归与分治</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/12动态规划">动态规划</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/13贪心算法">贪心算法</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/算法与数据结构/14回溯与分支极限">回溯与分支极限</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/计算机基础知识/">计算机基础知识</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item active" href="/知识库/计算机基础知识/操作系统基础">操作系统基础</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#引论">引论</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#并发与并行">并发与并行</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#系统调用">系统调用</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#用户态与核心态">用户态与核心态</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#其他">其他</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#处理器管理">处理器管理</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#进程概念">进程概念</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#进程基本状态转换图及转换原因">进程基本状态转换图及转换原因</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#进程并发运行的实质">进程并发运行的实质</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#调度算法">调度算法</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#线程的概念">线程的概念</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#进程同步与通信">进程同步与通信</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#进程同步或互斥的解决方案">进程同步或互斥的解决方案</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#解决互斥问题应遵循的四个准则">解决互斥问题应遵循的四个准则</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#用信号量解决基本的进程同步或互斥问题">用信号量解决基本的进程同步或互斥问题</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#进程通信">进程通信</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#死锁的含义">死锁的含义</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#死锁产生的原因">死锁产生的原因</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#死锁产生的必要条件">死锁产生的必要条件</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#死锁的具体解决方案">死锁的具体解决方案</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#存储管理">存储管理</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#各种存储管理方案的基本原理">各种存储管理方案的基本原理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#不同存储管理方案的地址变换，逻辑地址到物理地址的转换">不同存储管理方案的地址变换，逻辑地址到物理地址的转换</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#虚拟存储器的定义理解和特征">虚拟存储器的定义理解和特征</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#常见页面置换算法的置换原则，-页面序列或地址序列-缺页率">常见页面置换算法的置换原则，(页面序列或地址序列)缺页率</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#设备管理">设备管理</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#设备控制方式">设备控制方式</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#缓冲区的作用与类型">缓冲区的作用与类型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#磁盘访问时间组成">磁盘访问时间组成</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#常见磁盘调度算法">常见磁盘调度算法</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#文件管理">文件管理</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#文件目录结构todo">文件目录结构TODO</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#文件物理结构todo">文件物理结构TODO</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#文件共享方法todo">文件共享方法TODO</a><!----></li></ul></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/计算机基础知识/操作系统内存分配模拟程序">操作系统内存分配模拟程序</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/JavaScript/">JavaScript</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/JavaScript/这道题原来可以用到JS这么多知识点！">这道题原来可以用到JS这么多知识点！</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/JavaScript/TypeScript">TypeScript</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/CSS相关/">CSS相关</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/CSS相关/01都2022年了，还是得学圣杯布局与双飞翼布局">圣杯布局与双飞翼布局</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/前端框架/">前端框架</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/前端框架/01Vue3是如何运行的">Vue3是如何运行的</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/前端框架/02Vue3编译器">Vue3编译器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/前端框架/03虚拟DOM">虚拟DOM</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/前端框架/04Vue3-Reactivity">Vue3-Reactivity</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/前端框架/05Mini-Vue">Mini-Vue</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/前端框架/06Vue3其他">Vue3其他</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/UI组件库/">UI组件库</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/数据相关/">数据相关</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/后端储备/">后端储备</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/后端储备/Django进阶学习笔记">Django进阶学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/后端储备/DRF学习笔记">DRF学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/后端储备/Redis学习笔记">Redis学习笔记</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/AI相关/">AI相关</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/知识库/AI相关/TFIDF计算的学习">TFIDF计算的学习</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h2 id="引论" tabindex="-1">引论 <a class="header-anchor" href="#引论" aria-hidden="true">#</a></h2><h3 id="并发与并行" tabindex="-1">并发与并行 <a class="header-anchor" href="#并发与并行" aria-hidden="true">#</a></h3><blockquote><p>操作系统都具有并发性、共享性、虚拟性、不确定性等共同特征，其中，并发是操作系统中最重要的特征，其他三个特征都是以并发为前提的；</p></blockquote><p>并发：从宏观上看，这些进程是同时进行并向前推进的，从微观讲，任何时刻只能有一个进程执行，如果在单CPU条件下，那么这些进程就是在CPU上交替执行的；</p><p><strong>区别：</strong></p><p>并发和并行是两个不同的概念，并发是指两个或多个程序在同一时间段内同时执行，即宏观上并行，微观上串行；而并行性则是指同时执行，如不同硬件(CPU与IO设备)同时执行。</p><p><strong>补充：</strong></p><p>共享性：</p><blockquote><p>在内存中并发执行的多个进程可以同时使用系统中的资源（包括硬件资源和信息资源）。</p></blockquote><ul><li>互斥使用方式</li><li>同时使用方式</li></ul><p>虚拟性</p><p>异步性(不确定性)</p><ul><li>每个进程在多少时间内完成都是不可预知的；</li><li>并发进程的执行结果也可能不确定；</li><li>外部设备中段断、I/O请求、程序运行时发生中断的时间等都是不可预测的；</li></ul><h3 id="系统调用" tabindex="-1">系统调用 <a class="header-anchor" href="#系统调用" aria-hidden="true">#</a></h3><blockquote><p>隐藏了底层硬件的物理特性差异和复杂的处理细节，并向上提供方便、有效和安全的接口；</p><p>操作系统内核提供了一组具有特定功能的内核函数，并通过一组称为系统调用的接口呈现给用户使用；</p></blockquote><p>系统调用通常而称为陷阱，主要功能：</p><ul><li>产生一个访管中断，把CPU工作状态由原来的用户态转换为内核态；</li><li>执行对应的系统调用子程序（内核函数）；</li><li>系统调用子程序运行完成后将CPU工作状态切换回用户态；</li></ul><p>实现过程：</p><ul><li><p>系统产生软中断，CPU由用户态切换为内核态，保存用户程序的现场信息；</p></li><li><p>分析功能号并在入口地址地址表中查找对应的系统调用子程序（内核函数），有时还需要进行安全控制检查；</p></li><li><p>执行系统调用子程序并得到结果；</p></li><li><p>恢复用户程序的现场信息，CPU切换回用户态并返回结果，必要时进行安全检查；</p><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108181023530.png" alt="image-20220108181023530"></p><blockquote><p>此外，对于单用户、单任务操作系统(DOS)来说，只有在一个系统调用执行完成后，才能开始对另一个系统调用，即“内核不可重入”</p></blockquote></li></ul><h3 id="用户态与核心态" tabindex="-1">用户态与核心态 <a class="header-anchor" href="#用户态与核心态" aria-hidden="true">#</a></h3><ul><li>内核态 <ul><li>特点：指操作系统程序运行的状态，在该状态下可以执行操作系统的所有指令（包括特权指令），并能够使用系统的全部资源；</li><li>优势：访问的资源多；</li><li>缺点：可靠性、安全性要求高，维护管理比较复杂；</li></ul></li><li>用户态 <ul><li>特点：指用户程序运行的状态，在该状态下所能执行的指令和访问的资源都将受到限制；</li><li>优势：可靠性、安全性要求低，编写程序和维护管理都比较简单；</li><li>缺点：访问的资源有限；</li></ul></li><li>举例：文件系统本身的管理必须放在内核态下，否则人格人都有可能破坏文件系统的结构，用户文件（程序和数据）的管理则可以放在用户态下；</li><li>内核态与用户态的转换： <ul><li>中断和异常时CPU从用户态转换到内核态的唯一途径；</li><li>当CPU处于内核态时，可以通过修改程序状态字（PSW）直接进入用户态运行；</li><li>当CPU处于用户态时，如果需要切换到内核态则一般是通过访管指令或系统调用来实现；</li><li>访管指令和系统调用的主要功能： <ul><li>通过中断实现从用户态到内核态的改变；</li><li>在内核态下由操作系统代替用户完成其请求（用户指定的操作）；</li><li>操作系统完成指定操作后再修改程序状态字(PSW)由内核态切换回用户态；</li></ul></li></ul></li><li>补充：PSW主要用来控制指令的执行顺序，并保留与运行程序相关的各种信息；</li></ul><h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-hidden="true">#</a></h3><ul><li><p>什么是操作系统？</p><p>操作系统是驾驭计算机硬件和应用软件之间的一个软件系统，即操作系统的下面是硬件平台，而上面是软件平台。</p></li><li><p>操作系统是掌控计算机上所有事情的系统软件，它需要完成以下5种功能：</p><ul><li>控制和管理计算机系统的所有硬件和软件资源；</li><li>合理组织计算机的工作流程，保证计算机资源的公平竞争和使用；</li><li>方便用户使用计算机；</li><li>防止对计算机资源的非法侵占和使用；</li><li>保证操作系统自身的正常运转</li></ul></li><li><p>操作系统的逻辑结构</p><ul><li>单内核结构 <ul><li>内核在结构上可以看成一个整体，操作系统运行在内核态下，内核代码高度集成；</li><li>优点：结构紧密，模块间可以方便地组合以满足不同地需求，灵活性较好，效率高；</li><li>缺点：对模块功能的划分往往不能精确确定，模块的独立性较差；模块之间的调用关系复杂，导致系统结构不清晰正确性和可靠性不容易保证，系统维护也比较困难；</li></ul></li><li>分层式结构 <ul><li>优点：模块之间的依赖、调用关系更加清晰和规范；</li><li>系统的效率会受到一定的影响；</li></ul></li><li>微内核结构 <ul><li>仅将系统的一部分核心功能放如内核；</li><li>只完成极少的核心态任务，如进程管理和调度、内存管理、消息传递和设备驱动等，内核构成了操作系统的基本部分；</li><li>优点： <ul><li>为进程的请求提供了一致性接口，不必区分内核级服务和用户级服务，所有服务均采用消息传递机制提供；</li><li>具有较好的科扩充性和易修改性；</li><li>可移植性好；</li><li>对分布式系统提供有力支持；</li></ul></li><li>缺点：虽然运行效率比分层式结构有所提升，但仍然不够高，这是因为进程之间必须通过内核的通信机制才能相互通信；</li></ul></li></ul></li><li><p>中断技术</p><ul><li><p>中断机制是实现多道程序并发执行的重要条件，能改变操作的执行顺序；</p></li><li><p>特点：随机、可恢复、自动处理；</p></li><li><p>中断向量：每个中断有一个唯一的与其对应的中断向量号（通常为中断类型号），并按照中断向量号从小到大的顺序放在中断向量表中，因此系统可以根据中断向量的不同，来为中断请求提供不同的中断服务；</p></li><li><p>检测中断的硬件机构：中断扫描机构</p></li><li><p>中断发现过程：</p><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108165007571.png" alt="image-20220108165007571"></p></li><li><p>中断处理过程包括硬件操作和中断处理程序操作两部分：</p><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108164829508.png" alt="image-20220108164829508"></p></li><li><p>中断处理过程;</p><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108165318419.png" alt="image-20220108165318419"></p></li></ul></li></ul><h2 id="处理器管理" tabindex="-1">处理器管理 <a class="header-anchor" href="#处理器管理" aria-hidden="true">#</a></h2><h3 id="进程概念" tabindex="-1">进程概念 <a class="header-anchor" href="#进程概念" aria-hidden="true">#</a></h3><p>定义：进程是一个可并发执行的、具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位；</p><p>PCB：一个数据结构，用来存储程序向前推进的执行过程中所要记录的有关运行信息，即该进程动态执行的相关资源；</p><p>特征：</p><ul><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性</li><li>结构性</li></ul><p>进程与程序的区别：进程是正在执行的程序；</p><h3 id="进程基本状态转换图及转换原因" tabindex="-1">进程基本状态转换图及转换原因 <a class="header-anchor" href="#进程基本状态转换图及转换原因" aria-hidden="true">#</a></h3><h5 id="两态模型" tabindex="-1">两态模型 <a class="header-anchor" href="#两态模型" aria-hidden="true">#</a></h5><p>运行-&gt;非运行</p><h5 id="三态模型" tabindex="-1">三态模型 <a class="header-anchor" href="#三态模型" aria-hidden="true">#</a></h5><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108185600838.png" alt="image-20220108185600838"></p><p>重点：哪些可以转换，哪些不能转换：</p><ul><li>进程由就绪态变迁到运行态是由进程调度程序完成的；</li><li>运行变迁到阻塞状态，通常是由运行进程自身提出的</li><li>进程由阻塞状态变迁为就绪态总是由外界事件引起的。因为处于阻塞状态的进程没有任何活动能力；</li><li>进程由运行状态变为就绪状态通常在分时操作系统中出现；</li><li>进程不能由阻塞状态直接变迁到运行状态；</li></ul><h5 id="五态模型" tabindex="-1">五态模型 <a class="header-anchor" href="#五态模型" aria-hidden="true">#</a></h5><blockquote><p>引入了创建状态和终止状态</p></blockquote><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108190426184.png" alt="image-20220108190426184"></p><p>新增了三个进程状态变迁：</p><ul><li>由空到创建状态；</li><li>由创建状态变迁到就绪状态；</li><li>运行状态变迁到终止状态；</li></ul><h5 id="进程的挂起" tabindex="-1">进程的挂起 <a class="header-anchor" href="#进程的挂起" aria-hidden="true">#</a></h5><blockquote><p>采用交换技术将内存中的进程暂时移出保存到外存；</p></blockquote><p>进程挂起的原因：</p><ul><li>用户的请求；</li><li>父进程的请求；</li><li>操作系统的原因： <ul><li>交换：内存不足，需要平衡系统负载；</li><li>出现问题或故障时；</li><li>操作系统的需要，为监视系统的活动；</li></ul></li></ul><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108193627760.png" alt="image-20220108193627760"></p><p>增加了6种状态转换关系：</p><p>总体来说就是多了内存空间不足的处理，其他和三态一致；</p><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108215953004.png" alt="image-20220108215953004"></p><h3 id="进程并发运行的实质" tabindex="-1">进程并发运行的实质 <a class="header-anchor" href="#进程并发运行的实质" aria-hidden="true">#</a></h3><h5 id="程序的顺序执行特点：" tabindex="-1">程序的顺序执行特点： <a class="header-anchor" href="#程序的顺序执行特点：" aria-hidden="true">#</a></h5><ul><li>顺序性</li><li>封闭性</li><li>可再现性</li><li>不能并行工作，资源利用率低，计算机系统效率不高；</li></ul><h5 id="程序的并发执行" tabindex="-1">程序的并发执行: <a class="header-anchor" href="#程序的并发执行" aria-hidden="true">#</a></h5><blockquote><p>在计算机硬件引入通道和中断机构后，就使得CPU与外部设备之间，以及外部设备与外部设备之间可以并行操作；</p><p>资源共享一方面提高了资源的利用率，另一方面却引发了多个并发程序对资源的竞争；</p></blockquote><ul><li>间断性</li><li>失去了封闭性</li><li>不可再现性</li></ul><h3 id="调度算法" tabindex="-1">调度算法 <a class="header-anchor" href="#调度算法" aria-hidden="true">#</a></h3><blockquote><p>分析多进程的调度情况，计算平均周转时间、带权周转时间</p></blockquote><p>周转时间</p><ul><li>周转时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>=完成时间-提交时间；</li><li>周转时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>=运行时间+等待时间；</li></ul><p>带权周转时间（越大越不公平）</p><ul><li>带权周转时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>=周转时间/运行时间=1+等待时间/运行时间</li></ul><p>平均周转时间</p><ul><li><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108205327919.png" alt="image-20220108205327919"></li></ul><p>平均带权周转时间</p><ul><li><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108205400125.png" alt="image-20220108205400125"></li></ul><p>响应时间：提交一个请求开始，知道系统首次产生响应为止的时间间隔；</p><p>截止时间：某实时任务必须完成的最迟时间；</p><h5 id="先来先服务-fcfs" tabindex="-1">先来先服务(FCFS) <a class="header-anchor" href="#先来先服务-fcfs" aria-hidden="true">#</a></h5><ul><li>优点：实现简单，保证了一定的公平性；</li><li>没有考虑作业的类型和进程/线程执行时间的长短，短作业或IO进程/线程等待时间过长；</li><li><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108205842310.png" alt="image-20220108205842310"></li></ul><h5 id="短作业优先-sjf-spf" tabindex="-1">短作业优先(SJF/SPF) <a class="header-anchor" href="#短作业优先-sjf-spf" aria-hidden="true">#</a></h5><ul><li>每次从后备作业队列中，选择估计运行时间最短的作业进入内存，并创建相应的进程；</li><li>优点：有效地降低作业/进程地平均等待时间、提高系统的吞吐量（单位时间内完成工作的一种度量）；</li><li>缺点：预估时间不一定准确，长作业/长进程可能长时间等待而得不到运行；</li><li><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108210143285.png" alt="image-20220108210143285"></li></ul><h5 id="最短剩余时间优先" tabindex="-1">最短剩余时间优先 <a class="header-anchor" href="#最短剩余时间优先" aria-hidden="true">#</a></h5><p>剩余时间越短优先级越高</p><h5 id="高响应比优先-hrrf" tabindex="-1">高响应比优先(HRRF) <a class="header-anchor" href="#高响应比优先-hrrf" aria-hidden="true">#</a></h5><ul><li><p>动态优先数的非抢占式调度算法</p></li><li><p>其中的优先数也称为响应比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">R_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">p</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p></li><li> R_p = 响应时间/运行时间=1+等待时间/运行时间 <p>其中等待时间在变，而运行时间需要预估；</p></li><li><p>优点：既照顾短作业/短进程，又不会使长作业/长进程等待时间过长；</p></li><li><p>缺点：需要预估运行时间；需要计算响应比，会消耗不少的CPU时间；</p></li><li><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220108213308331.png" alt="image-20220108213308331"></p></li></ul><h5 id="静态优先级" tabindex="-1">静态优先级() <a class="header-anchor" href="#静态优先级" aria-hidden="true">#</a></h5><p>作业/进程在进入系统或创建时被赋予一个优先级，该优先级一旦确定则在整个生命期内不再改变。对于作业，其优先级可依据费用来确定；对于进程，其优先级主要依据进程的类型（系统进程还是用户进程）、进程的资源需求（资源需求少的进程优先级高）、时间需求（短进程优先）和用户要求来确定；</p><ul><li>优点：简单，系统开销小；</li><li>缺点：不够公平也不灵活；</li></ul><h5 id="时间片轮转-rr" tabindex="-1">时间片轮转(RR) <a class="header-anchor" href="#时间片轮转-rr" aria-hidden="true">#</a></h5><ul><li>进程/线程每次使用CPU的时间只能是一个时间片，当运行进程/线程用完规定的时间片时必须放弃CPU的使用权；</li><li>时间片很长：则可能大多数进程/线程都能在一个时间片内完成，退化为FCFS调度算法；</li><li>时间片很短：切换频繁，消耗系统资源；</li><li>实际上是一种基于时钟的抢占式调度算法；</li></ul><h3 id="线程的概念" tabindex="-1">线程的概念 <a class="header-anchor" href="#线程的概念" aria-hidden="true">#</a></h3><blockquote><p>引入线程后，进程就仅仅是资源的基本单位</p></blockquote><p>线程：CPU调度和执行的最小单位</p><p>其他提法（便于理解）</p><ul><li>进程内的一个执行单元；</li><li>进程内的一个可独立调度实体；</li><li>线程是进程中一个相对独立的控制流序列；</li><li>线程是执行的上下文；</li></ul><p>线程具有以下4个属性：</p><ul><li>线程属于轻型实体，基本不拥有系统资源，只拥有保证其运行而必不可少的资源。如仅有一个线程控制块（TCB）、程序计数器（PC）、一组寄存器及堆栈等；</li><li>线程是独立调度和分配的基本单位，也是能够独立运行的基本单位；</li><li>同一个进程中的所有线程共享该进程所拥有的全部资源；</li><li>不同进程的多个线程也可以并发执行；</li></ul><p>其他：</p><ul><li>线程也有生命周期；</li><li>由于线程不是资源的拥有单位，因此挂起状态对单个线程没有意义（挂起状态是进程级，而不是线程级）</li><li>线程终止后并不立即释放它所占用的系统资源；</li></ul><h2 id="进程同步与通信" tabindex="-1">进程同步与通信 <a class="header-anchor" href="#进程同步与通信" aria-hidden="true">#</a></h2><blockquote><ul><li>间接制约关系：资源共享；</li><li>直接制约关系：进程间合作；</li><li>进程同步：若干进程为完成一个共同的任务而合作；</li><li>进程互斥：某一资源同一时间只允许一个进程对其进行访问；</li><li>临界资源：一段时间内只允许一个进程使用的资源称为临界资源；</li><li>把进程中访问临界资源的代码称为临界区；</li></ul></blockquote><h3 id="进程同步或互斥的解决方案" tabindex="-1">进程同步或互斥的解决方案 <a class="header-anchor" href="#进程同步或互斥的解决方案" aria-hidden="true">#</a></h3><h5 id="硬件方法（了解）" tabindex="-1">硬件方法（了解） <a class="header-anchor" href="#硬件方法（了解）" aria-hidden="true">#</a></h5><ul><li>开中断指令</li><li>测试与设置指令TS</li><li>交换指令</li></ul><h5 id="软件方法（能想出来具体代码）" tabindex="-1">软件方法（能想出来具体代码） <a class="header-anchor" href="#软件方法（能想出来具体代码）" aria-hidden="true">#</a></h5><ul><li>两标志进程互斥算法；</li><li>改进后的两标志进程互斥算法；</li><li>三标志进程互斥算法；</li></ul><h3 id="解决互斥问题应遵循的四个准则" tabindex="-1">解决互斥问题应遵循的四个准则 <a class="header-anchor" href="#解决互斥问题应遵循的四个准则" aria-hidden="true">#</a></h3><ul><li>空闲让进；</li><li>忙则等待</li><li>有限等待；</li><li>让权等待；</li></ul><h3 id="用信号量解决基本的进程同步或互斥问题" tabindex="-1">用信号量解决基本的进程同步或互斥问题 <a class="header-anchor" href="#用信号量解决基本的进程同步或互斥问题" aria-hidden="true">#</a></h3><ul><li>司机进程与售票员进程；</li><li>两进程的三态模型；</li><li>生产者-消费者问题；</li><li>哲学家进餐问题；</li><li>读者-写者问题</li></ul><h3 id="进程通信" tabindex="-1">进程通信 <a class="header-anchor" href="#进程通信" aria-hidden="true">#</a></h3><p>进程的独立性造成了进程之间无法直接交换数据，而需要借助进程通信机制来实现；</p><ul><li>发送、接收双方经过实现约定，利用磁盘等外存设备由发送进程A把要交换恶的数据写入外存的指定区域中</li><li>利用内核运行在内核的特点，发送进程A通过内核程序，将数据写入内核空间指定的区域，接收进程B则哦通过另一组内核程序从内核指定指定区域中读取数据，并写入接收进程B的内存数据空间，从而实现数据从进程A传送到进程B。不需要IO操作，因此速度快；</li><li>低级通信：进程之间一次只能传送很少的信息，比如信号量方式；</li><li>高级通信：进程间一次可以传送大量的信息</li></ul><h5 id="共享内存通信方式" tabindex="-1">共享内存通信方式 <a class="header-anchor" href="#共享内存通信方式" aria-hidden="true">#</a></h5><blockquote><p>在内存中划出一块内存区作为共享数据区，通信的进程双方将自己的虚拟地址空间映射到共享内存分区上，它是进程之间最快捷、最有效的一种通信方式，可以实现多个进程之间的信息交换，但如何实现对共享分区的互斥使用由编程人员完成；</p></blockquote><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220109152629862.png" alt="image-20220109152629862"></p><h5 id="消息缓冲通信方式（消息传递通信方式：利用操作系统提供的消息传递系统实现进程通信）" tabindex="-1">消息缓冲通信方式（消息传递通信方式：利用操作系统提供的消息传递系统实现进程通信） <a class="header-anchor" href="#消息缓冲通信方式（消息传递通信方式：利用操作系统提供的消息传递系统实现进程通信）" aria-hidden="true">#</a></h5><ul><li>消息缓冲通信属于直接通信方式；</li><li>对于发送者： <ul><li>发送完信息后不等消息被接收者接收就继续前进；</li><li>发送完消息后阻塞自己，直到收到接收者的消息回答后才继续前进；</li></ul></li><li>对于接收者： <ul><li>若有消息则接收这个消息后继续前进，若无消息则阻塞自己；</li><li>若有消息则接收这个消息后继续前进，若无消息则放弃接收消息而继续前进；</li></ul></li><li>成功的通信过程： <ul><li>发送者在发送消息前，先将自己的内存空间设置一个发送区，把欲发送的消息填入其中；</li><li>发送者申请一个消息缓冲区，将已准备好的消息从发送区送到该消息缓冲区，并将发送者进程的名字、消息的开始地址以及消息的长度等信息填入该消息缓冲区中，然后把该消息缓冲区挂在接收进程的消息链上；</li><li>接收者在接收消息前先在自己的内存空间设置相应的接收区；</li><li>接收者摘下消息链上的第一条消息，将该消息从消息缓冲区复制到接收区，然后释放该消息缓冲区；</li></ul></li><li>其中2、4步为原语操作，是为了解决以下可能出现的问题： <ul><li>接收进程的消息链是临界资源，即对消息队列的操作是临界区，应保证发送和接收满足互斥性；</li><li>前述通信过程的第四步要求接收者摘下消息链上的第一条消息，而此时消息缓冲区中可能没有消息存在；</li><li>消息链上也可能挂有多条消息，则如何管理消息连山给的多条消息；</li><li>可能同时i存在多个发送者申请消息缓冲区，也就是说消息缓冲区也是临界资源；</li></ul></li></ul><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220109164222969.png" alt="image-20220109164222969"></p><h5 id="信箱通信方式（消息传递通信方式）" tabindex="-1">信箱通信方式（消息传递通信方式） <a class="header-anchor" href="#信箱通信方式（消息传递通信方式）" aria-hidden="true">#</a></h5><blockquote><p>信箱通信方式又称为间接通信方式，对同步的要求没有那么严格；</p></blockquote><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220109164323563.png" alt="image-20220109164323563"></p><p>规则：</p><ul><li>若发送信件时信箱已满，则发送进程应转变成等待信件状态，直到信箱有空信格时才被唤醒；</li><li>若取信件时信箱中已无信件，则接收进程转变成等待信件状态，直到有信件时才被唤醒；</li></ul><p>步骤：</p><ul><li>接收者创建属于自己的私用信箱；</li><li>发送者产生一封信件；</li><li>发送者把信件投入接收者的私用信箱；</li><li>接收者从自己的私用信箱中读取信件；</li></ul><p>投递操作与读取操作采用原语的原因：</p><ul><li>3中发送者发送信件时可能信箱已满；</li><li>4中接收者读取信件时可能信箱已空；</li></ul><h5 id="管道通信方式（共享文件通信方式）" tabindex="-1">管道通信方式（共享文件通信方式） <a class="header-anchor" href="#管道通信方式（共享文件通信方式）" aria-hidden="true">#</a></h5><blockquote><p>指连接在两个进程之间的一个打开的共享文件；</p></blockquote><ul><li>管道专门用于通信；</li><li>管道只能单向传送数据；</li><li>在对管道进行读写操作过程中，发送者进程和接收者进程所需要的同步和互斥都由系统自动进行，即对用户透明；</li></ul><h3 id="死锁的含义" tabindex="-1">死锁的含义 <a class="header-anchor" href="#死锁的含义" aria-hidden="true">#</a></h3><p>指多个进程在并发执行过程中因争夺不可抢占资源而造成的一种僵局；</p><p>死锁与死循环的区别</p><p>死锁与饥饿的区别</p><p>死锁是偶然发生的：</p><p>资源竞争可能导致死锁但不一定就发生死锁，死锁的发生还取决于进程推进的速度，以及对不可抢占资源申请的顺序，也就是说，产生死锁的因素不仅与系统拥有的资源数量有关，而且与资源的分配策略（可抢占式还是不可抢占式）、进程对资源的使用顺序以及并发进程的推进速度有关；</p><h3 id="死锁产生的原因" tabindex="-1">死锁产生的原因 <a class="header-anchor" href="#死锁产生的原因" aria-hidden="true">#</a></h3><ul><li>系统资源不足；</li><li>进程推进顺序不当；</li></ul><h3 id="死锁产生的必要条件" tabindex="-1">死锁产生的必要条件 <a class="header-anchor" href="#死锁产生的必要条件" aria-hidden="true">#</a></h3><blockquote><p>必要：产生死锁这四个条件一定具备，只要有一个条件不具备，就一定没有产生死锁现象；</p></blockquote><ul><li>互斥条件；</li><li>请求和保持条件；</li><li>不可抢占条件；</li><li>循环等待条件；</li></ul><h3 id="死锁的具体解决方案" tabindex="-1">死锁的具体解决方案 <a class="header-anchor" href="#死锁的具体解决方案" aria-hidden="true">#</a></h3><h5 id="死锁的预防" tabindex="-1">死锁的预防 <a class="header-anchor" href="#死锁的预防" aria-hidden="true">#</a></h5><ul><li>破坏请求保持条件 <ul><li>每个进程在运行之前一次申请它需要的全部资源；</li><li>优点：安全、简单且易于实现；</li><li>缺点：进程一直无法推进，比如前面一段时间只需要9个资源而结束时才会去使用最后一个资源；</li></ul></li><li>破坏不可抢占条件 <ul><li>必须释放它已获得的全部资源而进入阻塞状态，待以后需要时重新申请；</li><li>缺点：资源已经被修改了，需要回退；</li></ul></li><li>破坏循环等待条件 <ul><li>采用资源有序分配策略</li><li>缺点：资源不同的编号方法对资源的利用率有重要影响，且很难找到最优的编号方法；</li></ul></li></ul><h5 id="死锁的避免" tabindex="-1">死锁的避免 <a class="header-anchor" href="#死锁的避免" aria-hidden="true">#</a></h5><p>银行家算法</p><ul><li>系统可用资源向量Available</li><li>最大需求矩阵Max</li><li>分配矩阵Allocation</li><li>需求矩阵Need</li><li>请求向量Request</li></ul><h5 id="死锁的检测" tabindex="-1">死锁的检测 <a class="header-anchor" href="#死锁的检测" aria-hidden="true">#</a></h5><p>死锁的资源分配图化简</p><h5 id="死锁的解除" tabindex="-1">死锁的解除 <a class="header-anchor" href="#死锁的解除" aria-hidden="true">#</a></h5><ul><li>撤销所有死锁进程；</li><li>让死锁进程回撤到正常执行状态的某个检查点；</li><li>按照某种顺序逐个撤销死锁进程，直到不再发生死锁为止；</li><li>采用抢占资源的策略直到不再发生死锁；</li></ul><h2 id="存储管理" tabindex="-1">存储管理 <a class="header-anchor" href="#存储管理" aria-hidden="true">#</a></h2><table><thead><tr><th>技术</th><th style="text-align:left;">说明</th><th>优势</th><th>弱点</th></tr></thead><tbody><tr><td>固定分区</td><td style="text-align:left;">在系统生成阶段，内存被划分成许多静态分区。进程可以被装入到大于或等于自身大小正好的分区中</td><td>实现简单，只需要极少的操作系统开销</td><td>由于有内部碎片，对内存的使用不充分；活动进程的最大数目是固定的</td></tr><tr><td>动态分区</td><td style="text-align:left;">分区是动态创建的，因而使得每个进程可以装入到与自身大小正好相等的分区中</td><td>没有内部碎片；可以更充分地使用内存</td><td>由于需要压缩外部碎片，处理器利用率低</td></tr><tr><td>简单分区</td><td style="text-align:left;">内存被划分成许多大小相等的页框；每个进程被划分成大小与页框相等的页；要装入进程，需要把进程包含的所有页都装入内存中不一定连续的某些动态分区中</td><td>没有外部碎片</td><td>有少量的内部碎片</td></tr><tr><td>简单分段</td><td style="text-align:left;">每个进程被划分伟许多段；要装入进程，需要把进程包含的所有段都装入到内存中不一定连续的某些动态分区中</td><td>没有内部碎片；相对于动态分区，提高了内存利用率，减少了开销</td><td>存在外部碎片</td></tr><tr><td>虚拟内存分页</td><td style="text-align:left;">除了不需要装入进程的所有页之外，与简单分页一样；非驻留页在以后需要时自动调入内存</td><td>没有外部碎片；支持更高道数的多道程序设计；巨大的虚拟地址空间；支持保护与共享</td><td>复杂的内存管理开销</td></tr><tr><td>虚拟内存分段</td><td style="text-align:left;">除了不需要装入进程的所有段之外，与简单分段一样；非驻留段在以后需要时自动调入内存</td><td>没有内部随拍你；支持度更高道数的多道程序设计；巨大的虚拟地址空间；支持保护和共享</td><td>复杂的内存管理开销</td></tr></tbody></table><h3 id="各种存储管理方案的基本原理" tabindex="-1">各种存储管理方案的基本原理 <a class="header-anchor" href="#各种存储管理方案的基本原理" aria-hidden="true">#</a></h3><p>TODO</p><h5 id="可变分区" tabindex="-1">可变分区 <a class="header-anchor" href="#可变分区" aria-hidden="true">#</a></h5><p>TODO</p><h5 id="分页" tabindex="-1">分页 <a class="header-anchor" href="#分页" aria-hidden="true">#</a></h5><p>TODO</p><h5 id="分段" tabindex="-1">分段 <a class="header-anchor" href="#分段" aria-hidden="true">#</a></h5><p>TODO</p><h5 id="请求分页" tabindex="-1">请求分页 <a class="header-anchor" href="#请求分页" aria-hidden="true">#</a></h5><p>TODO</p><h5 id="请求分段" tabindex="-1">请求分段 <a class="header-anchor" href="#请求分段" aria-hidden="true">#</a></h5><p>TODO</p><h3 id="不同存储管理方案的地址变换，逻辑地址到物理地址的转换" tabindex="-1">不同存储管理方案的地址变换，逻辑地址到物理地址的转换 <a class="header-anchor" href="#不同存储管理方案的地址变换，逻辑地址到物理地址的转换" aria-hidden="true">#</a></h3><p>TODO</p><h3 id="虚拟存储器的定义理解和特征" tabindex="-1">虚拟存储器的定义理解和特征 <a class="header-anchor" href="#虚拟存储器的定义理解和特征" aria-hidden="true">#</a></h3><p>TODO</p><h3 id="常见页面置换算法的置换原则，-页面序列或地址序列-缺页率" tabindex="-1">常见页面置换算法的置换原则，(页面序列或地址序列)缺页率 <a class="header-anchor" href="#常见页面置换算法的置换原则，-页面序列或地址序列-缺页率" aria-hidden="true">#</a></h3><p>TODO</p><h5 id="fifo" tabindex="-1">FIFO <a class="header-anchor" href="#fifo" aria-hidden="true">#</a></h5><p>TODO</p><h5 id="opt" tabindex="-1">OPT <a class="header-anchor" href="#opt" aria-hidden="true">#</a></h5><p>TODO</p><h5 id="lru" tabindex="-1">LRU <a class="header-anchor" href="#lru" aria-hidden="true">#</a></h5><p>TODO</p><h5 id="clock" tabindex="-1">Clock <a class="header-anchor" href="#clock" aria-hidden="true">#</a></h5><p>TODO</p><h5 id="改进clock算法" tabindex="-1">改进Clock算法 <a class="header-anchor" href="#改进clock算法" aria-hidden="true">#</a></h5><p>TODO</p><h2 id="设备管理" tabindex="-1">设备管理 <a class="header-anchor" href="#设备管理" aria-hidden="true">#</a></h2><h3 id="设备控制方式" tabindex="-1">设备控制方式 <a class="header-anchor" href="#设备控制方式" aria-hidden="true">#</a></h3><h5 id="程序控制" tabindex="-1">程序控制 <a class="header-anchor" href="#程序控制" aria-hidden="true">#</a></h5><h5 id="中断方式" tabindex="-1">中断方式 <a class="header-anchor" href="#中断方式" aria-hidden="true">#</a></h5><h5 id="dma" tabindex="-1">DMA <a class="header-anchor" href="#dma" aria-hidden="true">#</a></h5><h5 id="通道" tabindex="-1">通道 <a class="header-anchor" href="#通道" aria-hidden="true">#</a></h5><h3 id="缓冲区的作用与类型" tabindex="-1">缓冲区的作用与类型 <a class="header-anchor" href="#缓冲区的作用与类型" aria-hidden="true">#</a></h3><h3 id="磁盘访问时间组成" tabindex="-1">磁盘访问时间组成 <a class="header-anchor" href="#磁盘访问时间组成" aria-hidden="true">#</a></h3><h3 id="常见磁盘调度算法" tabindex="-1">常见磁盘调度算法 <a class="header-anchor" href="#常见磁盘调度算法" aria-hidden="true">#</a></h3><blockquote><p>磁盘请求服务序列及平均寻道长度</p></blockquote><h2 id="文件管理" tabindex="-1">文件管理 <a class="header-anchor" href="#文件管理" aria-hidden="true">#</a></h2><h3 id="文件目录结构todo" tabindex="-1">文件目录结构TODO <a class="header-anchor" href="#文件目录结构todo" aria-hidden="true">#</a></h3><h3 id="文件物理结构todo" tabindex="-1">文件物理结构TODO <a class="header-anchor" href="#文件物理结构todo" aria-hidden="true">#</a></h3><h3 id="文件共享方法todo" tabindex="-1">文件共享方法TODO <a class="header-anchor" href="#文件共享方法todo" aria-hidden="true">#</a></h3></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><!----></div></div><div class="updated" data-v-fb8d84c6><!----></div></footer><div class="next-and-prev-link" data-v-7eddb2c4 data-v-38ede35f><div class="container" data-v-38ede35f><div class="prev" data-v-38ede35f><a class="link" href="/知识库/计算机基础知识/" data-v-38ede35f><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-38ede35f><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-38ede35f>计算机基础知识</span></a></div><div class="next" data-v-38ede35f><a class="link" href="/知识库/计算机基础知识/操作系统内存分配模拟程序" data-v-38ede35f><span class="text" data-v-38ede35f>操作系统内存分配模拟程序</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-38ede35f><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"1d8dde93\",\"推荐_typescript.md\":\"e40898d9\",\"推荐_index.md\":\"4ed1a4be\",\"推荐_动态规划.md\":\"11724621\",\"推荐_操作系统内存分配模拟程序.md\":\"e90f85be\",\"推荐_散列表实现查找.md\":\"6c0c112c\",\"推荐_这道题原来可以用到js这么多知识点！.md\":\"07db4206\",\"推荐_都2022年了，还是得学圣杯布局与双飞翼布局.md\":\"012f0078\",\"知识库_ai相关_tfidf计算的学习.md\":\"c9265030\",\"知识库_ai相关_index.md\":\"3a66f3b5\",\"知识库_css相关_01都2022年了，还是得学圣杯布局与双飞翼布局.md\":\"4d37581d\",\"知识库_css相关_index.md\":\"a71bbada\",\"知识库_javascript_typescript.md\":\"37a96a07\",\"知识库_javascript_index.md\":\"e7ebe10c\",\"知识库_javascript_这道题原来可以用到js这么多知识点！.md\":\"857449e5\",\"知识库_ui组件库_index.md\":\"2bd6def9\",\"知识库_index.md\":\"af41836f\",\"知识库_前端框架_01vue3是如何运行的.md\":\"969fdbb9\",\"知识库_前端框架_02vue3编译器.md\":\"fd46348e\",\"知识库_前端框架_03虚拟dom.md\":\"6ef7f095\",\"知识库_前端框架_04vue3-reactivity.md\":\"da98e3db\",\"知识库_前端框架_05mini-vue.md\":\"66aee536\",\"知识库_前端框架_06vue3其他.md\":\"3aaeab65\",\"知识库_前端框架_index.md\":\"7afb1c04\",\"知识库_后端储备_drf学习笔记.md\":\"96a743e3\",\"知识库_后端储备_django进阶学习笔记.md\":\"ea44ee8c\",\"知识库_后端储备_redis学习笔记.md\":\"9812981b\",\"知识库_后端储备_index.md\":\"28a806b0\",\"知识库_数据相关_index.md\":\"67502efc\",\"知识库_算法与数据结构_01基础概念.md\":\"5244ec12\",\"知识库_算法与数据结构_02线性表.md\":\"8a428a9c\",\"知识库_算法与数据结构_03栈和队列.md\":\"b0027a00\",\"知识库_算法与数据结构_04数组.md\":\"a1395525\",\"知识库_算法与数据结构_05树.md\":\"4a380226\",\"知识库_算法与数据结构_06图.md\":\"2a1ea4ea\",\"知识库_算法与数据结构_07查找.md\":\"4661eacb\",\"知识库_算法与数据结构_08排序.md\":\"9272c4cb\",\"知识库_算法与数据结构_09散列表实现查找.md\":\"1e4488fd\",\"知识库_算法与数据结构_10算法概述.md\":\"325360a3\",\"知识库_算法与数据结构_11递归与分治.md\":\"b6ab08ff\",\"知识库_算法与数据结构_12动态规划.md\":\"13832bb6\",\"知识库_算法与数据结构_13贪心算法.md\":\"07808a4e\",\"知识库_算法与数据结构_14回溯与分支界限.md\":\"7ee0c267\",\"知识库_算法与数据结构_index.md\":\"e2aa4fb8\",\"知识库_计算机基础知识_index.md\":\"c086ad1b\",\"知识库_计算机基础知识_操作系统内存分配模拟程序.md\":\"cd88e67f\",\"知识库_计算机基础知识_操作系统基础.md\":\"268c0b83\"}")</script>
    <script type="module" async src="/assets/app.0b1f5e83.js"></script>
    
  </body>
</html>