<!DOCTYPE html>
<html lang="zh-CH">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>图 | Justin3go's Blog-🖊</title>
    <meta name="description" content="我的技术博客，用心记录知识碎片，汇总整理程序员知识。">
    <link rel="stylesheet" href="/assets/style.e85a6420.css">
    <link rel="modulepreload" href="/assets/Home.c8febe17.js">
    <link rel="modulepreload" href="/assets/app.f32a81e4.js">
    <link rel="modulepreload" href="/assets/汇总分类_算法与数据结构_06图.md.f1248b1b.lean.js">
    
    <link rel="icon" href="/ava.ico">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-alpha/dist/katex.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css">
  <meta name="twitter:title" content="图 | Justin3go&#39;s Blog-🖊">
  <meta property="og:title" content="图 | Justin3go&#39;s Blog-🖊">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="Justin3go&#39;s Blog-🖊, back to home" data-v-675d8756 data-v-cc01ef16><!----> Justin3go&#39;s Blog-🖊</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/" data-v-b8818f8c>首页 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item active" href="/汇总分类/" data-v-b8818f8c>汇总分类 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/推荐/" data-v-b8818f8c>站长推荐 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://space.bilibili.com/434542518" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>B站 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://github.com/Justin3go" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/" data-v-b8818f8c>首页 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item active" href="/汇总分类/" data-v-b8818f8c>汇总分类 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/推荐/" data-v-b8818f8c>站长推荐 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://space.bilibili.com/434542518" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>B站 <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://github.com/Justin3go" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/算法与数据结构/">算法与数据结构</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/算法与数据结构/01基础概念">基础概念</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/算法与数据结构/02线性表">线性表</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/算法与数据结构/03栈和队列">栈和队列</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/算法与数据结构/04数组">数组</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/算法与数据结构/05树">树</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/汇总分类/算法与数据结构/06图">图</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#图的关键词">图的关键词</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#图的存储">图的存储</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#邻接矩阵">邻接矩阵</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#邻接表">邻接表</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#十字链表">十字链表</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#边集数组">边集数组</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#图的遍历">图的遍历</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#图的拓扑排序">图的拓扑排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#图的最小生成树">图的最小生成树</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#生成树">生成树</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#图的最小生成树-1">图的最小生成树</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#prim算法">PRIM算法</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#kruskal算法">Kruskal算法</a><!----></li></ul></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/算法与数据结构/07查找">查找</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/算法与数据结构/08排序">排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/算法与数据结构/09散列表实现查找">散列表实现查找</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/计算机基础知识/">计算机基础知识</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/JavaScript/">JavaScript</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/CSS相关/">CSS相关</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/前端框架/">前端框架</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/UI组件库/">UI组件库</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/数据相关/">数据相关</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/后端储备/">后端储备</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/汇总分类/AI相关/">AI相关</a><!----></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h1 id="图" tabindex="-1">图 <a class="header-anchor" href="#图" aria-hidden="true">#</a></h1><h2 id="图的关键词" tabindex="-1">图的关键词 <a class="header-anchor" href="#图的关键词" aria-hidden="true">#</a></h2><ul><li>完全图 <ul><li>无向图需要有n(n-1)/2条边。</li><li>有向图需要有n(n-1)条弧。</li></ul></li><li>邻接点</li><li>度（有向图还有出度和入度）</li><li>子图</li><li>路径</li><li>路径长度</li><li>简单路径：顶点不重复出现的路径。</li><li>回路：第一个顶点和最后一个顶点相同的路径。</li><li>简单回路：除第一顶点和最后以顶点外，其余顶点不重复出现的回路。</li><li>权：在图的每条边上加数字作权。</li><li>网：带权的图称为网。</li></ul><hr><ul><li><p>连通：无向图中，如果从顶点v到顶点v~有路径，则称v和v~是连通的。</p></li><li><p><strong>连通图</strong>：如果图中任意两个顶点都是连通的，则是连通图。</p></li><li><p><strong>连通分量</strong>相关：</p><ul><li>也叫无向图的<strong>极大连通子图</strong></li><li>连通图只有一个连通分量，即其自身</li><li>非连通的无向图有多个连通分量</li></ul></li><li><p><strong>强连通图</strong>：有向图中每一对顶点都存在路径，则称G是强连通图。</p></li><li><p><strong>强连通分量</strong>：</p><ul><li>有向图的极大连通子图称作强连通分量。</li><li>强连通图的强连通分量是其自身</li><li>非强连通的有向图可能有多个强连通分量</li></ul></li><li><p>生成树</p><ul><li>一个连通图的<strong>极小连通子图</strong></li><li>含有图中全部n个顶点，但只有能令图连通的n-1条边</li></ul><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20210609191424667.png" alt="image-20210609191424667" style="zoom:50%;"></li></ul><h2 id="图的存储" tabindex="-1">图的存储 <a class="header-anchor" href="#图的存储" aria-hidden="true">#</a></h2><h3 id="邻接矩阵" tabindex="-1">邻接矩阵 <a class="header-anchor" href="#邻接矩阵" aria-hidden="true">#</a></h3><p>创建<strong>顶点集</strong>和创建<strong>关系集</strong></p><div class="language-cpp"><pre><code><span class="token comment">//图的邻接矩阵存储</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NMAX</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> datatype<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    datatype vexes<span class="token punctuation">[</span>NMAX<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> edge<span class="token punctuation">[</span>NMAX<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>NMAX<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">,</span>e
<span class="token punctuation">}</span>graph<span class="token punctuation">;</span>
graph <span class="token operator">*</span>ga<span class="token punctuation">;</span>
</code></pre></div><p>算法思路：</p><div class="language-"><pre><code>step1:创建ga的存储空间
step2:输入边数ga-&gt;e
step3:输入顶点数ga-&gt;n
step4:初始化顶点集ga-&gt;vexes
	foreach k in (1~ga-&gt;n)
		输入顶点的数据data
		ga-&gt;vexes[k]=data
step5:初始化邻接矩阵ga-&gt;edges为全0
step6:创建边集
	foreach k in (1~ga-&gt;e)
		输入边的顶点偶对：（i,j）
		ga-&gt;edges[i][j]=1
		ga-&gt;edges[j][i]=1
step7:return ga
</code></pre></div><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20210609194316082.png" alt="image-20210609194316082" style="zoom:50%;"><h3 id="邻接表" tabindex="-1">邻接表 <a class="header-anchor" href="#邻接表" aria-hidden="true">#</a></h3><p>顶点表</p><p><strong>边表：边表结点保存着与某顶点关联的另一顶点和指向下一表结点的指针</strong></p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20210609194419001.png" alt="image-20210609194419001" style="zoom:50%;"><p><strong>邻接表结构</strong>定义：</p><div class="language-cpp"><pre><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NMAX</span> <span class="token expression"><span class="token number">100</span>  </span><span class="token comment">//顶点的最大数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>  <span class="token comment">//边表结点</span>
    <span class="token keyword">int</span> vertex<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>edgenode<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>  <span class="token comment">//顶点表结点</span>
    vextype data<span class="token punctuation">;</span>
    edgenode<span class="token operator">*</span> head<span class="token punctuation">;</span>  <span class="token comment">//边表头指针</span>
<span class="token punctuation">}</span>vexnode<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>  <span class="token comment">//图的定义</span>
    vexnode vexes<span class="token punctuation">[</span>NMAX<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//顶点表</span>
    <span class="token keyword">int</span> n<span class="token punctuation">,</span> e<span class="token punctuation">;</span>  <span class="token comment">//顶点数、边数</span>
<span class="token punctuation">}</span>graph<span class="token punctuation">;</span>
graph <span class="token operator">*</span>ga<span class="token punctuation">;</span>
</code></pre></div><p>算法思路：</p><div class="language-python"><pre><code><span class="token comment">#初始化顶点表ga-&gt;vexes</span>
<span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">~</span>ga<span class="token operator">-</span><span class="token operator">&gt;</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 输入数据data</span>
    ga<span class="token operator">-</span><span class="token operator">&gt;</span>vexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data
    ga<span class="token operator">-</span><span class="token operator">&gt;</span>vexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>head <span class="token operator">=</span> NULL
<span class="token comment">#创建边表集</span>
<span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">~</span>ga<span class="token operator">-</span><span class="token operator">&gt;</span>e<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 输入边的顶点对（i，j）</span>
    <span class="token comment"># 将顶点j添加到顶点i的边表中</span>
    	<span class="token comment"># 生成边表结点p</span>
        <span class="token comment"># 结点数据域赋值：p-&gt;vertex=j</span>
        <span class="token comment"># 在边表中加入结点p</span>
        	<span class="token comment"># p-&gt;next=ga-&gt;vertex[i].head</span>
            <span class="token comment"># ga-&gt;vertex[i].head=p</span>
    <span class="token comment"># 将顶点i添加到顶点j的边表中</span>
</code></pre></div><h3 id="十字链表" tabindex="-1">十字链表 <a class="header-anchor" href="#十字链表" aria-hidden="true">#</a></h3><div class="language-cpp"><pre><code><span class="token comment">//边表结点</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">arctype</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> tailvex<span class="token punctuation">,</span> headvex<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">arctype</span> <span class="token operator">*</span>hlink<span class="token punctuation">,</span><span class="token operator">*</span>tlink<span class="token punctuation">;</span>
<span class="token punctuation">}</span>arclink<span class="token punctuation">;</span>

<span class="token comment">//顶点表结点</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">vnode</span><span class="token punctuation">{</span>
    vertex data<span class="token punctuation">;</span>
    arclink <span class="token operator">*</span>firstin<span class="token punctuation">,</span> <span class="token operator">*</span>firstout<span class="token punctuation">;</span>
<span class="token punctuation">}</span>ortholistNode
ortholistNode graph<span class="token punctuation">[</span>NMAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220120202043847.png" alt="image-20220120202043847"></p><h3 id="边集数组" tabindex="-1">边集数组 <a class="header-anchor" href="#边集数组" aria-hidden="true">#</a></h3><div class="language-cpp"><pre><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> fromvex<span class="token punctuation">;</span><span class="token comment">//边的起点</span>
    <span class="token keyword">int</span> endvex<span class="token punctuation">;</span><span class="token comment">//边的终点</span>
    <span class="token keyword">int</span> weight<span class="token punctuation">;</span><span class="token comment">//边的权值</span>
<span class="token punctuation">}</span>EDGE<span class="token punctuation">;</span>
EDGE edgeet<span class="token punctuation">[</span>MaxEDGEnUM<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220120202023107.png" alt="image-20220120202023107"></p><h2 id="图的遍历" tabindex="-1">图的遍历 <a class="header-anchor" href="#图的遍历" aria-hidden="true">#</a></h2><p>要求：<strong>无重复、无遗漏</strong>。</p><p>关键点：</p><ul><li>图中可能<strong>存在回路</strong>。</li><li>顶点可能与其它顶点相通，访问完某顶点后，可能沿着某些边回到曾经访问过的顶点。</li><li>为<strong>避免重复访问</strong>，可设辅助数组visited[] <ul><li>将其初始化为0.</li><li>遍历时，如果某顶点i被访问，将visited[i]置为1。</li><li>以此防止顶点i被多次访问。</li></ul></li></ul><p><strong>深度优先</strong>(递归解法)：</p><div class="language-cpp"><pre><code><span class="token comment">//邻接矩阵：</span>
<span class="token keyword">for</span> k <span class="token function">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">~</span>n<span class="token punctuation">)</span>
    visied<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">DFS</span><span class="token punctuation">(</span>ga<span class="token punctuation">,</span> vi<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>vi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//访问结点vi</span>
    visited<span class="token punctuation">[</span>vi<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> k <span class="token function">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">~</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>ga<span class="token operator">-&gt;</span>edges<span class="token punctuation">[</span>vi<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token function">DFS</span><span class="token punctuation">(</span>ga<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp"><pre><code><span class="token comment">//邻接表：</span>
<span class="token keyword">for</span> k <span class="token function">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">~</span>n<span class="token punctuation">)</span>
    visied<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">DFS</span><span class="token punctuation">(</span>ga<span class="token punctuation">,</span> vi<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>vi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    visited<span class="token punctuation">[</span>vi<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    p<span class="token operator">=</span><span class="token punctuation">(</span>ga<span class="token operator">-&gt;</span>vexes<span class="token punctuation">[</span>vi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>p<span class="token operator">-&gt;</span>vertex<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token function">DFS</span><span class="token punctuation">(</span>ga<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>vertex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>深度优先（栈）：</p><div class="language-"><pre><code>step1:设初始状态：图中所有顶点都没被访问过
foreach i in (1~n)
	visited[i] = 0;
step2:初始化栈stack
step3:c=r,push(stack,c) //r为出发顶点的编号
step4:访问顶点vc,令visited[c]=1
step5:找到并访问与顶点vc邻接，但未被访问过的顶点v_j
for(j:1~n)
	if(ga[c][j] == 1 and visited[j] == 0)
		c = j, push(stack, j)转step4
step6:当vc所有的邻接点均被访问过，则退回到最近被访问的前一顶点。
	if(!emptystack(stack))
		c=pop(stack),转step5
    else return;
</code></pre></div><p><strong>广度优先</strong>：类似于<strong>树的层次遍历</strong>，使用<strong>队列</strong>辅助存储。</p><p><strong>图的连通性</strong>：如果遍历完成时DFS或BFS仅调用一次，则图是连通图；若被调用多次，则图是非连通图，分别访问多个连通分量。</p><h2 id="图的拓扑排序" tabindex="-1">图的拓扑排序 <a class="header-anchor" href="#图的拓扑排序" aria-hidden="true">#</a></h2><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20210609210740434.png" alt="image-20210609210740434" style="zoom:50%;"><p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20220120202006590.png" alt="image-20220120202006590"></p><p>AOV：</p><ul><li>顶点表示活动，弧表示活动间的先后关系。</li><li>AOV网中不能有回路，回路意味着某项活动以自己为先决条件。</li><li>死锁。</li></ul><p>拓扑排序：</p><ul><li>把AOV网中各顶点按其活动的先后关系，排列成一个线性序列的过程。</li><li>拓扑序列</li><li>AOV网用邻接表存储</li><li>在邻接表的表头结点增加存放顶点入度的域。</li><li><strong>栈或队列存放入度为零的顶点</strong>。</li></ul><div class="language-"><pre><code>拓扑排序：对有n个顶点的有向图ga，以邻接表方式存储，找出一条拓扑序列。
step1:初始化栈stack，令count=0
step2:创建ga的邻接表，初始化每个顶点的入度为0
step3:将当前可开始的活动入栈
	foreach k in 1~n
		if(ga-&gt;vexes[k].indegree==0)
			push(stack, k)
step4:while(!empty(stack))
	vi = pop(stack)
	visit(vi),count++
	将后续活动的入度减1，并记录新的可开始的活动。
		p=ga-&gt;vexes[vi].head
		while(p)
			ga-&gt;vexes[p-&gt;data].indegree--
			if(ga-&gt;vexes[p-&gt;data].indegree==0)
				push(stack,p-&gt;data)
            p = p-&gt;next;
step3:如仍有活动未进行，return FALSE,否则return TRUE
	if(count&lt;n)
		return FALSE;
</code></pre></div><h2 id="图的最小生成树" tabindex="-1">图的最小生成树 <a class="header-anchor" href="#图的最小生成树" aria-hidden="true">#</a></h2><h3 id="生成树" tabindex="-1">生成树 <a class="header-anchor" href="#生成树" aria-hidden="true">#</a></h3><ul><li>连通图G的极小连通子图，称为图的生成树</li><li>包含图中所有顶点</li><li>无回路 <ul><li><strong>n个顶点，只有n-1条边。</strong></li><li>任意去掉一条边，图将变为非连通图</li><li>添加一条边，图中将出现回路</li></ul></li><li><strong>含n个顶点n-1的图不一定是最小生成树</strong></li><li>深度优先生成树</li><li>广度优先生成树</li><li>图的生成树不是唯一的</li><li>从不同的顶点出发，可得到不同的生成树。</li></ul><h3 id="图的最小生成树-1" tabindex="-1">图的最小生成树 <a class="header-anchor" href="#图的最小生成树-1" aria-hidden="true">#</a></h3><ul><li>连通网络G=（V，E）的各边带权</li><li>因此其生成树各边带权</li><li>生成树的权 <ul><li>生成树各边权值的和</li></ul></li><li><strong>最小生成树（MST）</strong><ul><li>权值最小的生成树</li></ul></li></ul><h3 id="prim算法" tabindex="-1">PRIM算法 <a class="header-anchor" href="#prim算法" aria-hidden="true">#</a></h3><p>初始U中含任意一个顶点u0，初始候选边集<img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20210609213706268.png" alt="image-20210609213706268" style="zoom:50%;"></p><ul><li>numv=1</li><li>while(numv=1){</li><li>​ 从C中选最短边并入边集E，点集U</li><li>​ numv++</li><li>​ 调整候选边集C<img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20210609214143152.png" alt="image-20210609214143152" style="zoom:50%;"></li><li>}</li></ul><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20210609214218953.png" alt="image-20210609214218953" style="zoom:50%;"><h3 id="kruskal算法" tabindex="-1">Kruskal算法 <a class="header-anchor" href="#kruskal算法" aria-hidden="true">#</a></h3><p>算法思想：权值由小到大开始来连接，连通的不要，直到生成生成树，即最小生成树。</p><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20210609214529186.png" alt="image-20210609214529186" style="zoom:50%;"><img src="https://webplus-cn-shenzhen-s-6130b804f968dd14cecc43e2.oss-cn-shenzhen.aliyuncs.com/blogs/image-20210609214547290.png" alt="image-20210609214547290" style="zoom:50%;"><!----></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><!----></div></div><div class="updated" data-v-fb8d84c6><!----></div></footer><div class="next-and-prev-link" data-v-7eddb2c4 data-v-38ede35f><div class="container" data-v-38ede35f><div class="prev" data-v-38ede35f><a class="link" href="/汇总分类/算法与数据结构/05树" data-v-38ede35f><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-38ede35f><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-38ede35f>树</span></a></div><div class="next" data-v-38ede35f><a class="link" href="/汇总分类/算法与数据结构/07查找" data-v-38ede35f><span class="text" data-v-38ede35f>查找</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-38ede35f><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"8b43ba6d\",\"推荐_09散列表实现查找.md\":\"8bdc743d\",\"推荐_index.md\":\"6c678fe2\",\"汇总分类_ai相关_index.md\":\"89416a96\",\"汇总分类_css相关_index.md\":\"e08c3b32\",\"汇总分类_javascript_index.md\":\"53fb0275\",\"汇总分类_ui组件库_index.md\":\"edcd9c2f\",\"汇总分类_index.md\":\"09559be7\",\"汇总分类_前端框架_index.md\":\"86388555\",\"汇总分类_后端储备_index.md\":\"371abea5\",\"汇总分类_数据相关_index.md\":\"b1ab4697\",\"汇总分类_算法与数据结构_01基础概念.md\":\"26357042\",\"汇总分类_算法与数据结构_02线性表.md\":\"81a00244\",\"汇总分类_算法与数据结构_03栈和队列.md\":\"3fcf8e1c\",\"汇总分类_算法与数据结构_04数组.md\":\"6aab33ad\",\"汇总分类_算法与数据结构_05树.md\":\"85fd1da9\",\"汇总分类_算法与数据结构_06图.md\":\"f1248b1b\",\"汇总分类_算法与数据结构_07查找.md\":\"a64c613f\",\"汇总分类_算法与数据结构_08排序.md\":\"332cf2bd\",\"汇总分类_算法与数据结构_09散列表实现查找.md\":\"a96cfee5\",\"汇总分类_算法与数据结构_index.md\":\"2e6084f4\",\"汇总分类_计算机基础知识_index.md\":\"31755ee9\"}")</script>
    <script type="module" async src="/assets/app.f32a81e4.js"></script>
    
  </body>
</html>